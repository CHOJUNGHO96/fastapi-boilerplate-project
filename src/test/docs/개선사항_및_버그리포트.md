# ê°œì„ ì‚¬í•­ ë° ë²„ê·¸ ë¦¬í¬íŠ¸

## ê°œìš”

E2E í…ŒìŠ¤íŠ¸ êµ¬í˜„ ê³¼ì •ì—ì„œ ë°œê²¬ëœ ë²„ê·¸ ë° ê°œì„ ì‚¬í•­ì„ ë¬¸ì„œí™”í•©ë‹ˆë‹¤.
ê° í•­ëª©ì€ í”„ë¡¬í”„íŠ¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ í˜•ì‹ìœ¼ë¡œ ì‘ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

**ì‘ì„±ì¼**: 2026-01-28
**í”„ë¡œì íŠ¸**: FastAPI Boilerplate - ì¸ì¦ ì‹œìŠ¤í…œ
**ë‹´ë‹¹ì**: ê°œë°œíŒ€

---

## ğŸ”´ ë²„ê·¸ ë¦¬í¬íŠ¸

### ë²„ê·¸ #1: Redis ìºì‹œì— None ì €ì¥ (ë†’ìŒ)

**ìš°ì„ ìˆœìœ„**: ğŸ”´ ë†’ìŒ (Critical)
**ìƒíƒœ**: ğŸ” í™•ì¸ë¨ (Confirmed)
**ë°œê²¬ì¼**: 2026-01-28
**ë‹´ë‹¹ì**: ë¯¸í• ë‹¹

#### ë¬¸ì œ ì„¤ëª…

`src/infrastructure/db/redis.py`ì˜ `set_user_cache` ë©”ì„œë“œì—ì„œ `cache_user`ê°€ `None`ì¼ ë•Œ Redisì— `None` ê°’ì„ ì €ì¥í•˜ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤.

**ë¬¸ì œ íŒŒì¼**: `src/infrastructure/db/redis.py:33-36`

```python
# í˜„ì¬ ì½”ë“œ (ë²„ê·¸ ìˆìŒ)
async def set_user_cache(self, login_id: str, cache_user: BaseModel | None = None) -> None:
    await self.redis.set(
        key=f"cache_user_info_{login_id}",
        value=cache_user.json() if cache_user else None,  # âŒ Noneì´ ì €ì¥ë¨
    )
```

#### ì˜í–¥ ë²”ìœ„

1. **ë¡œê·¸ì¸ í”Œë¡œìš°**:
   - `LoginUseCase` â†’ `CacheService.set_user_cache()` í˜¸ì¶œ
   - cache_userê°€ Noneì¸ ê²½ìš° Redisì— ë¹ˆ ê°’ ì €ì¥
   - ì´í›„ ìºì‹œ ì¡°íšŒ ì‹œ ì˜ˆìƒê³¼ ë‹¤ë¥¸ ë™ì‘ ë°œìƒ

2. **í…ŒìŠ¤íŠ¸ ì˜í–¥**:
   - `test_login_redis_cache_created` - skip ì²˜ë¦¬ë¨
   - `test_logout_redis_cache_removed` - ìºì‹œ ì—†ì–´ì„œ skip
   - ëª¨ë“  ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸ - ìºì‹œ ê²€ì¦ ì‹¤íŒ¨ ê°€ëŠ¥

3. **í”„ë¡œë•ì…˜ ì˜í–¥**:
   - ì‚¬ìš©ì ì •ë³´ ìºì‹± ì‹¤íŒ¨
   - ë¶ˆí•„ìš”í•œ DB ì¿¼ë¦¬ ì¦ê°€
   - ì„±ëŠ¥ ì €í•˜

#### ì¬í˜„ ë°©ë²•

```python
# í…ŒìŠ¤íŠ¸ ì½”ë“œ
from infrastructure.db.redis import RedisService

redis_service = RedisService()
await redis_service.set_user_cache("test_user", None)  # None ì €ì¥ ì‹œë„

# ê²°ê³¼: Redisì— None ë˜ëŠ” "null" ë¬¸ìì—´ ì €ì¥ë¨
```

#### ì œì•ˆëœ ìˆ˜ì •

**ì˜µì…˜ A: Early Return (ê¶Œì¥)**
```python
async def set_user_cache(self, login_id: str, cache_user: BaseModel | None = None) -> None:
    if cache_user is None:
        logger.warning(f"Attempted to cache None for user {login_id}")
        return  # Noneì¸ ê²½ìš° ìºì‹œ ì €ì¥í•˜ì§€ ì•ŠìŒ

    await self.redis.set(
        key=f"cache_user_info_{login_id}",
        value=cache_user.json(),
        ex=3600,  # 1ì‹œê°„ TTL ì¶”ê°€
    )
```

**ì˜µì…˜ B: Exception ë°œìƒ**
```python
async def set_user_cache(self, login_id: str, cache_user: BaseModel | None = None) -> None:
    if cache_user is None:
        raise ValueError(f"Cannot cache None value for user {login_id}")

    await self.redis.set(
        key=f"cache_user_info_{login_id}",
        value=cache_user.json(),
        ex=3600,
    )
```

#### í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

ìˆ˜ì • í›„ ë‹¤ìŒ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•´ì•¼ í•¨:

```python
@pytest.mark.asyncio
async def test_set_user_cache_with_none_should_not_store(redis):
    """None ê°’ì€ Redisì— ì €ì¥ë˜ì§€ ì•Šì•„ì•¼ í•¨"""
    from infrastructure.db.redis import RedisService

    redis_service = RedisService()
    await redis_service.set_user_cache("test_user", None)

    # Redisì— ìºì‹œê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
    cache_key = "cache_user_info_test_user"
    cached_value = await redis.get(cache_key)
    assert cached_value is None, "None ê°’ì€ ìºì‹œì— ì €ì¥ë˜ë©´ ì•ˆë¨"
```

#### ê´€ë ¨ ì´ìŠˆ

- í…ŒìŠ¤íŠ¸_ì§„í–‰_ìƒí™©.md - ì´ìŠˆ #1
- ì—¬ëŸ¬ í…ŒìŠ¤íŠ¸ì—ì„œ workaround ì‚¬ìš© ì¤‘

---

### ë²„ê·¸ #2: refresh_token ì—”ë“œí¬ì¸íŠ¸ ë³´ì•ˆ í”Œë˜ê·¸ ëˆ„ë½ (ë†’ìŒ)

**ìš°ì„ ìˆœìœ„**: ğŸ”´ ë†’ìŒ (Security)
**ìƒíƒœ**: ğŸ” í™•ì¸ë¨ (Confirmed)
**ë°œê²¬ì¼**: 2026-01-28
**ë‹´ë‹¹ì**: ë¯¸í• ë‹¹

#### ë¬¸ì œ ì„¤ëª…

`refresh_token` ì—”ë“œí¬ì¸íŠ¸ì—ì„œ ì¿ í‚¤ ì„¤ì • ì‹œ ë³´ì•ˆ í”Œë˜ê·¸(`httponly`, `secure`, `samesite`)ë¥¼ ëˆ„ë½í•˜ì—¬ ë³´ì•ˆ ì·¨ì•½ì ì´ ë°œìƒí•©ë‹ˆë‹¤.

**ë¬¸ì œ íŒŒì¼**: `src/app/auth/endpoint/refresh_token.py:43-45`

```python
# í˜„ì¬ ì½”ë“œ (ë³´ì•ˆ í”Œë˜ê·¸ ì—†ìŒ)
response.set_cookie(key="access_token", value=access_token)
response.set_cookie(key="refresh_token", value=new_refresh_token)
```

**ì˜¬ë°”ë¥¸ ì˜ˆì‹œ**: `src/app/auth/endpoint/login.py:41-63`

```python
# login.py - ì˜¬ë°”ë¥¸ ë³´ì•ˆ í”Œë˜ê·¸ ì‚¬ìš©
response.set_cookie(
    key="access_token",
    value=access_token,
    httponly=True,   # âœ… JavaScript ì ‘ê·¼ ì°¨ë‹¨
    secure=True,     # âœ… HTTPSë§Œ ì „ì†¡
    samesite="lax",  # âœ… CSRF ë°©ì–´
)
```

#### ë³´ì•ˆ ì·¨ì•½ì 

1. **XSS ê³µê²©** (httponly ì—†ìŒ):
   - JavaScriptë¡œ ì¿ í‚¤ ì ‘ê·¼ ê°€ëŠ¥
   - ì•…ì„± ìŠ¤í¬ë¦½íŠ¸ê°€ í† í° íƒˆì·¨ ê°€ëŠ¥

2. **ì¤‘ê°„ì ê³µê²©** (secure ì—†ìŒ):
   - HTTP ì—°ê²°ì—ì„œë„ ì¿ í‚¤ ì „ì†¡
   - ë„¤íŠ¸ì›Œí¬ ìŠ¤ë‹ˆí•‘ìœ¼ë¡œ í† í° íƒˆì·¨ ê°€ëŠ¥

3. **CSRF ê³µê²©** (samesite ì—†ìŒ):
   - ë‹¤ë¥¸ ì‚¬ì´íŠ¸ì—ì„œ ì¿ í‚¤ ì‚¬ìš© ê°€ëŠ¥
   - í¬ë¡œìŠ¤ ì‚¬ì´íŠ¸ ìš”ì²­ ìœ„ì¡° ê°€ëŠ¥

#### ì˜í–¥ ë²”ìœ„

- í† í° ê°±ì‹  ì‹œ ìƒˆë¡œ ë°œê¸‰ëœ í† í°ì´ ì•ˆì „í•˜ì§€ ì•ŠìŒ
- í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì‹¬ê°í•œ ë³´ì•ˆ ìœ„í˜‘
- ë¡œê·¸ì¸ ì‹œì—ëŠ” ì˜¬ë°”ë¥¸ í”Œë˜ê·¸ ì‚¬ìš©, ê°±ì‹  ì‹œì—ëŠ” ëˆ„ë½ (ì¼ê´€ì„± ì—†ìŒ)

#### ì œì•ˆëœ ìˆ˜ì •

```python
# src/app/auth/endpoint/refresh_token.py ìˆ˜ì •

@router.get("/refresh_token")
async def refresh_token(
    request: Request,
    refresh_token: str = Cookie(None),
    refresh_use_case: RefreshTokenUseCase = Depends(Provide[Container.refresh_token_use_case]),
):
    result = await refresh_use_case.execute(refresh_token, request)

    response = JSONResponse(
        status_code=status.HTTP_200_OK,
        content={"msg": "success"},
    )

    # ë³´ì•ˆ í”Œë˜ê·¸ ì¶”ê°€ âœ…
    response.set_cookie(
        key="access_token",
        value=result["access_token"],
        httponly=True,   # JavaScript ì ‘ê·¼ ì°¨ë‹¨
        secure=True,     # HTTPSë§Œ ì „ì†¡
        samesite="lax",  # CSRF ë°©ì–´
    )

    response.set_cookie(
        key="refresh_token",
        value=result["refresh_token"],
        httponly=True,
        secure=True,
        samesite="lax",
    )

    return response
```

#### ì¶”ê°€ ê¶Œì¥ì‚¬í•­

1. **ì¿ í‚¤ ì„¤ì • í—¬í¼ í•¨ìˆ˜ ìƒì„±**:
```python
# src/app/auth/utils/cookie_helper.py (ì‹ ê·œ íŒŒì¼)

from fastapi import Response

def set_auth_cookie(
    response: Response,
    key: str,
    value: str,
    max_age: int = 3600,
) -> None:
    """
    ë³´ì•ˆ í”Œë˜ê·¸ê°€ ì ìš©ëœ ì¸ì¦ ì¿ í‚¤ ì„¤ì •

    Args:
        response: FastAPI Response ê°ì²´
        key: ì¿ í‚¤ í‚¤ (access_token, refresh_token ë“±)
        value: ì¿ í‚¤ ê°’ (JWT í† í°)
        max_age: ì¿ í‚¤ ìœ íš¨ ì‹œê°„ (ì´ˆ)
    """
    response.set_cookie(
        key=key,
        value=value,
        httponly=True,
        secure=True,
        samesite="lax",
        max_age=max_age,
    )
```

2. **ëª¨ë“  ì—”ë“œí¬ì¸íŠ¸ì— ì ìš©**:
   - `login.py` - ì´ë¯¸ ì˜¬ë°”ë¦„ âœ…
   - `refresh_token.py` - ìˆ˜ì • í•„ìš” âŒ
   - `logout.py` - ì¿ í‚¤ ì‚­ì œ ì‹œì—ë„ í”Œë˜ê·¸ í•„ìš” âš ï¸

#### í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

```python
@pytest.mark.asyncio
async def test_refresh_token_cookies_have_security_flags(async_client, authenticated_user):
    """refresh_token ì—”ë“œí¬ì¸íŠ¸ê°€ ë³´ì•ˆ í”Œë˜ê·¸ë¥¼ ì„¤ì •í•˜ëŠ”ì§€ í™•ì¸"""
    tokens = authenticated_user["tokens"]

    response = await AuthHelper.refresh_token(
        async_client,
        tokens["refresh_token"],
    )

    assert response.status_code == 200

    # ì¿ í‚¤ ë³´ì•ˆ í”Œë˜ê·¸ í™•ì¸
    for cookie in response.cookies.jar:
        if cookie.name in ["access_token", "refresh_token"]:
            # httpxì—ì„œëŠ” ëª¨ë“  í”Œë˜ê·¸ì— ì ‘ê·¼ ë¶ˆê°€í•˜ì§€ë§Œ,
            # ë¸Œë¼ìš°ì € í…ŒìŠ¤íŠ¸ì—ì„œëŠ” í™•ì¸ ê°€ëŠ¥
            assert cookie.value, f"Cookie {cookie.name} should have value"
            # TODO: Playwrightë¡œ ì‹¤ì œ ë¸Œë¼ìš°ì €ì—ì„œ í”Œë˜ê·¸ í™•ì¸
```

#### ê´€ë ¨ ì´ìŠˆ

- í…ŒìŠ¤íŠ¸_ì§„í–‰_ìƒí™©.md - ì´ìŠˆ #2
- `test_refresh_token_new_cookies_set` - í”Œë˜ê·¸ ê²€ì¦ ë³´ë¥˜ ì¤‘

---

## ğŸŸ¡ ê°œì„ ì‚¬í•­

### ê°œì„  #1: í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜ í†µí•© ë° ìµœì í™”

**ìš°ì„ ìˆœìœ„**: ğŸŸ¡ ì¤‘ê°„ (Enhancement)
**ìƒíƒœ**: ğŸ’¡ ì œì•ˆë¨ (Proposed)
**ì œì•ˆì¼**: 2026-01-28

#### í˜„ì¬ ìƒí™©

í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜ê°€ ì—¬ëŸ¬ íŒŒì¼ì— ë¶„ì‚°ë˜ì–´ ìˆê³ , ì¤‘ë³µë˜ëŠ” ì„¤ì • ì½”ë“œê°€ ìˆìŠµë‹ˆë‹¤.

#### ì œì•ˆì‚¬í•­

**í†µí•© í”½ìŠ¤ì²˜ ê´€ë¦¬ í´ë˜ìŠ¤ ìƒì„±**:

```python
# src/test/fixtures/test_manager.py (ì‹ ê·œ íŒŒì¼)

from dataclasses import dataclass
from typing import Dict, Any
from httpx import AsyncClient


@dataclass
class TestUser:
    """í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ë°ì´í„° ë° í† í°ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤"""
    login_id: str
    email: str
    password: str
    user_name: str
    user_type: str
    user_id: int | None = None
    access_token: str | None = None
    refresh_token: str | None = None
    token_type: str = "Bearer"

    @classmethod
    async def create_and_login(cls, client: AsyncClient) -> "TestUser":
        """ì‚¬ìš©ì ìƒì„± ë° ë¡œê·¸ì¸ì„ í•œ ë²ˆì— ì²˜ë¦¬"""
        from test.helpers.test_data_generator import generate_user_data
        from test.helpers.auth_helper import AuthHelper

        user_data = generate_user_data()

        # Register
        register_response = await AuthHelper.register_user(client, user_data)
        assert register_response.status_code == 200
        user_id = register_response.json()["user_id"]

        # Login
        login_response = await AuthHelper.login_user(
            client,
            user_data["login_id"],
            user_data["password"],
        )
        assert login_response.status_code == 200

        # Extract tokens
        tokens = AuthHelper.extract_tokens_from_cookies(login_response)

        return cls(
            login_id=user_data["login_id"],
            email=user_data["email"],
            password=user_data["password"],
            user_name=user_data["user_name"],
            user_type=user_data["user_type"],
            user_id=user_id,
            access_token=tokens.get("access_token"),
            refresh_token=tokens.get("refresh_token"),
            token_type=tokens.get("token_type", "Bearer"),
        )

    def get_cookies(self) -> Dict[str, str]:
        """ì¸ì¦ ì¿ í‚¤ ë”•ì…”ë„ˆë¦¬ ë°˜í™˜"""
        return {
            "token_type": self.token_type,
            "access_token": self.access_token,
            "refresh_token": self.refresh_token,
        }

    async def logout(self, client: AsyncClient):
        """ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒ"""
        from test.helpers.auth_helper import AuthHelper

        response = await AuthHelper.logout_user(client, cookies=self.get_cookies())
        assert response.status_code == 200
```

**ì‚¬ìš© ì˜ˆì‹œ**:

```python
@pytest.mark.asyncio
async def test_with_test_manager(async_client, clean_db):
    """TestUser í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•œ ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸"""
    from test.fixtures.test_manager import TestUser

    # ì‚¬ìš©ì ìƒì„± ë° ë¡œê·¸ì¸ì„ í•œ ë²ˆì—
    user = await TestUser.create_and_login(async_client)

    # ì¿ í‚¤ ì‚¬ìš©
    response = await async_client.get(
        "/api/v1/some_protected_endpoint",
        cookies=user.get_cookies(),
    )

    # ë¡œê·¸ì•„ì›ƒ
    await user.logout(async_client)
```

#### ì¥ì 

- í…ŒìŠ¤íŠ¸ ì½”ë“œ ê°„ê²°í™” (3-5ì¤„ë¡œ ì‚¬ìš©ì ìƒì„± ê°€ëŠ¥)
- íƒ€ì… ì•ˆì •ì„± í–¥ìƒ (dataclass ì‚¬ìš©)
- ì¬ì‚¬ìš©ì„± ì¦ê°€
- ìœ ì§€ë³´ìˆ˜ ìš©ì´

---

### ê°œì„  #2: ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜í™” ë° ì¤‘ì•™ ê´€ë¦¬

**ìš°ì„ ìˆœìœ„**: ğŸŸ¡ ì¤‘ê°„ (Enhancement)
**ìƒíƒœ**: ğŸ’¡ ì œì•ˆë¨ (Proposed)
**ì œì•ˆì¼**: 2026-01-28

#### í˜„ì¬ ìƒí™©

ì—ëŸ¬ ì½”ë“œê°€ í…ŒìŠ¤íŠ¸ ì½”ë“œì™€ í”„ë¡œë•ì…˜ ì½”ë“œì— í•˜ë“œì½”ë”©ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

```python
# í˜„ì¬ í…ŒìŠ¤íŠ¸ ì½”ë“œ
AuthHelper.assert_error_response(
    response,
    expected_status=400,
    expected_error_code=4010005,  # âŒ ë§¤ì§ ë„˜ë²„
)
```

#### ì œì•ˆì‚¬í•­

**ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜ ì •ì˜**:

```python
# src/errors.py ìˆ˜ì • (ê¸°ì¡´ íŒŒì¼ì— ì¶”ê°€)

class ErrorCode:
    """API ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜"""

    # ì¸ì¦ ì—ëŸ¬ (4010xxx)
    NOT_AUTHORIZATION = 4010001      # ì¸ì¦ í•„ìš”
    EXPIRE_JWT_TOKEN = 4010002       # í† í° ë§Œë£Œ
    NOT_FOUND_USER = 4010003         # ì‚¬ìš©ì ì—†ìŒ
    BAD_PASSWORD = 4010004           # ì˜ëª»ëœ ë¹„ë°€ë²ˆí˜¸
    DUPLICATE_USER = 4010005         # ì¤‘ë³µ ì‚¬ìš©ì
    INVALID_JWT_TOKEN = 4010006      # ì˜ëª»ëœ í† í°

    # í–¥í›„ í™•ì¥ ê°€ëŠ¥
    # PERMISSION_DENIED = 4010007
    # ACCOUNT_LOCKED = 4010008


# Exception í´ë˜ìŠ¤ì—ë„ ì ìš©
class NotAuthorization(APIException):
    status_code = 401
    error_code = ErrorCode.NOT_AUTHORIZATION  # âœ… ìƒìˆ˜ ì‚¬ìš©
    message = "Authorization Required"
```

**í…ŒìŠ¤íŠ¸ ì½”ë“œ ê°œì„ **:

```python
from errors import ErrorCode

# ê°œì„ ëœ í…ŒìŠ¤íŠ¸ ì½”ë“œ
AuthHelper.assert_error_response(
    response,
    expected_status=400,
    expected_error_code=ErrorCode.DUPLICATE_USER,  # âœ… ëª…í™•í•œ ìƒìˆ˜
)
```

#### ì¥ì 

- ì—ëŸ¬ ì½”ë“œì˜ ì˜ë¯¸ê°€ ëª…í™•í•¨
- ì˜¤íƒ€ ë°©ì§€ (IDE ìë™ì™„ì„±)
- ì¤‘ì•™ì—ì„œ ê´€ë¦¬ ìš©ì´
- ì—ëŸ¬ ì½”ë“œ ë³€ê²½ ì‹œ í•œ ê³³ë§Œ ìˆ˜ì •

---

### ê°œì„  #3: ë§Œë£Œëœ í† í° í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì‹œê°„ ì¡°ì‘ ìœ í‹¸ë¦¬í‹°

**ìš°ì„ ìˆœìœ„**: ğŸŸ¢ ë‚®ìŒ (Nice to have)
**ìƒíƒœ**: ğŸ’¡ ì œì•ˆë¨ (Proposed)
**ì œì•ˆì¼**: 2026-01-28

#### í˜„ì¬ ìƒí™©

ë§Œë£Œëœ í† í°ì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•´ ì‹¤ì œë¡œ í† í°ì´ ë§Œë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•˜ê±°ë‚˜, í…ŒìŠ¤íŠ¸ë¥¼ skip ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.

```python
@pytest.mark.asyncio
async def test_logout_with_expired_token(async_client, clean_db):
    """ë§Œë£Œëœ í† í° í…ŒìŠ¤íŠ¸ - í˜„ì¬ skip"""
    pytest.skip("Requires time manipulation to generate expired token")
```

#### ì œì•ˆì‚¬í•­

**ì‹œê°„ ì¡°ì‘ ìœ í‹¸ë¦¬í‹° ì¶”ê°€**:

```python
# src/test/helpers/token_helper.py (ì‹ ê·œ íŒŒì¼)

import jwt
from datetime import datetime, timedelta
from config import Config


class TokenHelper:
    """JWT í† í° ìƒì„± ë° ì¡°ì‘ í—¬í¼"""

    @staticmethod
    def create_expired_access_token(user_id: int, login_id: str) -> str:
        """ë§Œë£Œëœ access token ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)"""
        config = Config()

        # ê³¼ê±° ì‹œê°„ìœ¼ë¡œ ì„¤ì •
        expired_time = datetime.utcnow() - timedelta(hours=2)

        payload = {
            "user_id": user_id,
            "login_id": login_id,
            "exp": expired_time,
        }

        return jwt.encode(
            payload,
            config.JWT_SECRET_KEY,
            algorithm=config.JWT_ALGORITHM,
        )

    @staticmethod
    def create_expired_refresh_token(user_id: int, login_id: str) -> str:
        """ë§Œë£Œëœ refresh token ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)"""
        config = Config()

        expired_time = datetime.utcnow() - timedelta(days=8)  # 7ì¼ë³´ë‹¤ ì˜¤ë˜ëœ

        payload = {
            "user_id": user_id,
            "login_id": login_id,
            "exp": expired_time,
        }

        return jwt.encode(
            payload,
            config.JWT_REFRESH_SECRET_KEY,
            algorithm=config.JWT_ALGORITHM,
        )

    @staticmethod
    def create_token_expiring_soon(user_id: int, login_id: str, seconds: int = 5) -> str:
        """ê³§ ë§Œë£Œë  í† í° ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)"""
        config = Config()

        expiring_time = datetime.utcnow() + timedelta(seconds=seconds)

        payload = {
            "user_id": user_id,
            "login_id": login_id,
            "exp": expiring_time,
        }

        return jwt.encode(
            payload,
            config.JWT_SECRET_KEY,
            algorithm=config.JWT_ALGORITHM,
        )
```

**ê°œì„ ëœ í…ŒìŠ¤íŠ¸**:

```python
from test.helpers.token_helper import TokenHelper

@pytest.mark.asyncio
async def test_logout_with_expired_token(async_client, authenticated_user):
    """ë§Œë£Œëœ í† í°ìœ¼ë¡œ ë¡œê·¸ì•„ì›ƒ ì‹œë„"""
    user_data = authenticated_user["user_data"]
    user_id = authenticated_user["login_response"].json()["list"]["user_id"]

    # ë§Œë£Œëœ í† í° ìƒì„±
    expired_token = TokenHelper.create_expired_access_token(user_id, user_data["login_id"])

    # ë¡œê·¸ì•„ì›ƒ ì‹œë„
    response = await async_client.post(
        "/api/v1/auth/logout",
        cookies={
            "token_type": "Bearer",
            "access_token": expired_token,
            "refresh_token": "some_refresh_token",
        },
    )

    # ë§Œë£Œëœ í† í° ì—ëŸ¬ í™•ì¸
    AuthHelper.assert_error_response(
        response,
        expected_status=401,
        expected_error_code=ErrorCode.EXPIRE_JWT_TOKEN,
    )
```

#### ì¥ì 

- ë§Œë£Œ í† í° í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- ì‹œê°„ ëŒ€ê¸° ë¶ˆí•„ìš”
- ë‹¤ì–‘í•œ ë§Œë£Œ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥

---

## ğŸ“‹ êµ¬í˜„ ìš°ì„ ìˆœìœ„

| ìˆœìœ„ | í•­ëª© | ìœ í˜• | ì˜ˆìƒ ì‹œê°„ | ì˜í–¥ë„ |
|------|------|------|-----------|--------|
| 1 | ë²„ê·¸ #2: ë³´ì•ˆ í”Œë˜ê·¸ ëˆ„ë½ | ğŸ”´ ë²„ê·¸ | 30ë¶„ | ë†’ìŒ |
| 2 | ë²„ê·¸ #1: Redis ìºì‹œ None ì €ì¥ | ğŸ”´ ë²„ê·¸ | 1ì‹œê°„ | ë†’ìŒ |
| 3 | ê°œì„  #2: ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜í™” | ğŸŸ¡ ê°œì„  | 1ì‹œê°„ | ì¤‘ê°„ |
| 4 | ê°œì„  #1: í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜ í†µí•© | ğŸŸ¡ ê°œì„  | 2ì‹œê°„ | ì¤‘ê°„ |
| 5 | ê°œì„  #3: ì‹œê°„ ì¡°ì‘ ìœ í‹¸ë¦¬í‹° | ğŸŸ¢ ê°œì„  | 2ì‹œê°„ | ë‚®ìŒ |

---

## í”„ë¡¬í”„íŠ¸ í˜•ì‹ ê°œì„ ì‚¬í•­

ê° ê°œì„ ì‚¬í•­ì€ ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ì§ì ‘ í”„ë¡¬í”„íŠ¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:

### ë²„ê·¸ ìˆ˜ì • í”„ë¡¬í”„íŠ¸

```
Bug Fix: [ë²„ê·¸ #ë²ˆí˜¸] - [ì œëª©]

Problem:
[ë¬¸ì œ ì„¤ëª… ë° íŒŒì¼ ìœ„ì¹˜]

Current Code:
[í˜„ì¬ ì½”ë“œ]

Proposed Fix:
[ìˆ˜ì •ëœ ì½”ë“œ]

Test Cases:
[í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤]

Related Files:
- [ê´€ë ¨ íŒŒì¼ ëª©ë¡]
```

### ê°œì„ ì‚¬í•­ í”„ë¡¬í”„íŠ¸

```
Enhancement: [ê°œì„  #ë²ˆí˜¸] - [ì œëª©]

Current Situation:
[í˜„ì¬ ìƒí™©]

Proposed Solution:
[ì œì•ˆëœ í•´ê²°ì±… ë° ì½”ë“œ]

Benefits:
[ì¥ì  ëª©ë¡]

Implementation Steps:
[êµ¬í˜„ ë‹¨ê³„]
```

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë²„ê·¸ ìˆ˜ì •
- [ ] ë²„ê·¸ #1: Redis ìºì‹œ None ì €ì¥ ìˆ˜ì •
- [ ] ë²„ê·¸ #2: ë³´ì•ˆ í”Œë˜ê·¸ ëˆ„ë½ ìˆ˜ì •
- [ ] ìˆ˜ì • í›„ ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° í†µê³¼ í™•ì¸
- [ ] í”„ë¡œë•ì…˜ ë°°í¬ ì „ ê²€ì¦

### ê°œì„ ì‚¬í•­
- [ ] ê°œì„  #1: TestManager í´ë˜ìŠ¤ êµ¬í˜„
- [ ] ê°œì„  #2: ErrorCode ìƒìˆ˜ ì •ì˜ ë° ì ìš©
- [ ] ê°œì„  #3: TokenHelper ìœ í‹¸ë¦¬í‹° êµ¬í˜„
- [ ] ë¦¬íŒ©í† ë§ í›„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ í™•ì¸

### ë¬¸ì„œí™”
- [x] ë²„ê·¸ ë¦¬í¬íŠ¸ ì‘ì„±
- [x] ê°œì„ ì‚¬í•­ ë¬¸ì„œí™”
- [ ] API ë¬¸ì„œ ì—…ë°ì´íŠ¸
- [ ] CHANGELOG.md ì—…ë°ì´íŠ¸

---

## í›„ì† ì¡°ì¹˜

1. **ì¦‰ì‹œ ì¡°ì¹˜** (1-2ì¼):
   - ë³´ì•ˆ í”Œë˜ê·¸ ëˆ„ë½ ìˆ˜ì • (ë²„ê·¸ #2)
   - Redis ìºì‹œ ë²„ê·¸ ìˆ˜ì • (ë²„ê·¸ #1)

2. **ë‹¨ê¸° ì¡°ì¹˜** (1ì£¼ì¼):
   - ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜í™” (ê°œì„  #2)
   - í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜ í†µí•© (ê°œì„  #1)

3. **ì¥ê¸° ì¡°ì¹˜** (1ê°œì›”):
   - ì‹œê°„ ì¡°ì‘ ìœ í‹¸ë¦¬í‹° (ê°œì„  #3)
   - CI/CD íŒŒì´í”„ë¼ì¸ í†µí•©
   - ì¶”ê°€ E2E í…ŒìŠ¤íŠ¸ í™•ì¥

---

**ì°¸ê³  ë¬¸ì„œ**:
- í…ŒìŠ¤íŠ¸_ì§„í–‰_ìƒí™©.md - ì „ì²´ í…ŒìŠ¤íŠ¸ í˜„í™©
- CLAUDE.md - í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜
- src/errors.py - ì—ëŸ¬ ì •ì˜
